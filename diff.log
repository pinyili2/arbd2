diff src/Angle.cu /data/server2/pinyili2/arbd_software/arbd.after_server5/src/Angle.cu
18,29d17
< // void BondAngle::print()
< // {
< // //	printf("about to print fileName %p\n", fileName.val());
< // //	fileName.print();
< //     printf("BONDANGLE (%d %d %d) %s; %s; %s\n", ind1, ind2, ind3, angleFileName.val(), bondFileName1.val(), bondFileName2.val());
< // }
< 
< // String BondAngle::toString()
< // {
< //     return String("BONDANGLE ") + ind1 + " " + ind2 + " " + ind3 + " " + angleFileName + " " + bondFileName1 + " " + bondFileName2;
< // }
< 
diff src/Angle.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/Angle.h
62,113d61
< 
< // TODO consolidate with Angle using inheritence
< class BondAngle
< {
< public:
< 	BondAngle() {}
<     BondAngle(int ind1, int ind2, int ind3, int ind4, String angleFileName1, String bondFileName, String angleFileName2) :
< 	ind1(ind1), ind2(ind2), ind3(ind3), ind4(ind4), angleFileName1(angleFileName1), bondFileName(bondFileName), angleFileName2(angleFileName2), tabFileIndex1(-1), tabFileIndex2(-1), tabFileIndex3(-1) { }
< 
< 	int ind1, ind2, ind3, ind4;
< 
< 	String angleFileName1;
< 	String bondFileName;
< 	String angleFileName2;
< 	// tabFileIndex will be assigned after ComputeForce loads the
< 	// TabulatedAnglePotentials. The tabefileIndex is used by ComputeForce to
< 	// discern which TabulatedAnglePotential this Angle uses.
< 	int tabFileIndex1;
< 	int tabFileIndex2;
< 	int tabFileIndex3;
< 
<     inline BondAngle(const BondAngle& a) : ind1(a.ind1), ind2(a.ind2), ind3(a.ind3), ind4(a.ind4),
< 					   angleFileName1(a.angleFileName1), bondFileName(a.bondFileName), angleFileName2(a.angleFileName2),
< 					   tabFileIndex1(a.tabFileIndex1), tabFileIndex2(a.tabFileIndex2), tabFileIndex3(a.tabFileIndex3) { }
< 
< 	// HOST DEVICE inline float calcAngle(Vector3* pos, BaseGrid* sys) {
< 	// 	const Vector3& posa = pos[ind1];
< 	// 	const Vector3& posb = pos[ind2];
< 	// 	const Vector3& posc = pos[ind3];
< 	// 	const float distab = sys->wrapDiff(posa - posb).length();
< 	// 	const float distbc = sys->wrapDiff(posb - posc).length();
< 	// 	const float distac = sys->wrapDiff(posc - posa).length();
< 	// 	float cos = (distbc * distbc + distab * distab - distac * distac)
< 	// 						  / (2.0f * distbc * distab);
< 	// 	if (cos < -1.0f) cos = -1.0f;
< 	// 	else if (cos > 1.0f) cos = 1.0f;
< 	// 	float angle = acos(cos);
< 	// 	return angle;
< 	// }
< 
< 	// HOST DEVICE inline int getIndex(int index) {
< 	// 	if (index == ind1) return 1;
< 	// 	if (index == ind2) return 2;
< 	// 	if (index == ind3) return 3;
< 	// 	if (index == ind4) return 4;
< 	// 	return -1;
< 	// }
< 
< 	// String toString();
< 	// void print();
< };
< 
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Angle.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: arbd
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: arbd_link.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: BaseGrid.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: BrownianParticle.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: BrownianParticleType.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: CellDecomposition.o
diff src/ComputeForce.cu /data/server2/pinyili2/arbd_software/arbd.after_server5/src/ComputeForce.cu
52d51
<     numBondAngles(c.numBondAngles), numProductPotentials(c.numProductPotentials),
237,238d235
< 	bondAngleList_d = NULL;
< 	product_potential_list_d = NULL;
407c404
< bool ComputeForce::addBondPotential(String fileName, int ind, Bond bonds[], BondAngle bondAngles[])
---
> bool ComputeForce::addBondPotential(String fileName, int ind, Bond bonds[])
421,426d417
< 	for (int i = 0; i < numBondAngles; i++)
< 	{
< 	    if (bondAngles[i].bondFileName == fileName)
< 		bondAngles[i].tabFileIndex2 = ind;
< 	}
< 
435c426
< bool ComputeForce::addAnglePotential(String fileName, int ind, Angle* angles, BondAngle* bondAngles) {
---
> bool ComputeForce::addAnglePotential(String fileName, int ind, Angle* angles) {
464,469d454
< 	for (int i = 0; i < numBondAngles; i++) {
< 	    if (bondAngles[i].angleFileName1 == fileName)
< 		bondAngles[i].tabFileIndex1 = ind;
< 	    if (bondAngles[i].angleFileName2 == fileName)
< 		bondAngles[i].tabFileIndex3 = ind;
< 	}
732,742d716
< 
< 	if(product_potential_list_d != NULL && product_potentials_d != NULL)
< 	{
< 	    computeProductPotentials <<<nb, numThreads, 0, gpuman.get_next_stream()>>> ( forceInternal_d[0], pos_d[0], sys_d[0], numReplicas*numProductPotentials, product_potential_particles_d, product_potentials_d, product_potential_list_d, productCount_d, energies_d, get_energy);
< 	}
< 
< 	if(bondAngleList_d != NULL && tableBond_d != NULL && tableAngle_d != NULL)
< 	{
< 	    computeTabulatedBondAngles <<<nb, numThreads, 0, gpuman.get_next_stream()>>> ( forceInternal_d[0], pos_d[0], sys_d[0], numReplicas*numBondAngles, bondAngleList_d, tableAngle_d, tableBond_d, energies_d, get_energy);
< 	}
< 
769c743
< 	    computeHarmonicRestraints<<<1, numThreads, 0, gpuman.get_next_stream()>>>(forceInternal_d[0], pos_d[0], sys_d[0], numRestraints*numReplicas, restraintList_d, restraintLocs_d, restraintSprings_d);
---
> 	    computeHarmonicRestraints<<<1, numThreads, 0, gpuman.get_next_stream()>>>(forceInternal_d[0], pos_d[0], sys_d[0], numRestraints*numReplicas, restraintIds_d, restraintLocs_d, restraintSprings_d);
894c868
< void ComputeForce::copyToCUDA(int simNum, int *type, Bond* bonds, int2* bondMap, Exclude* excludes, int2* excludeMap, Angle* angles, Dihedral* dihedrals, const Restraint* const restraints, const BondAngle* const bondAngles, const XpotMap simple_potential_map, const std::vector<SimplePotential> simple_potentials, const ProductPotentialConf* const product_potential_confs)
---
> void ComputeForce::copyToCUDA(int simNum, int *type, Bond* bonds, int2* bondMap, Exclude* excludes, int2* excludeMap, Angle* angles, Dihedral* dihedrals, const Restraint* const restraints)
965,1063d938
< 	if (numBondAngles > 0) {
< 		gpuErrchk(cudaMalloc(&bondAngles_d, sizeof(BondAngle) * numBondAngles));
< 		gpuErrchk(cudaMemcpyAsync(bondAngles_d, bondAngles, sizeof(BondAngle) * numBondAngles,
< 				cudaMemcpyHostToDevice));
< 	}
< 
< 	if (simple_potentials.size() > 0) {
< 	    float **val = simple_potential_pots_d = new float*[simple_potentials.size()];
< 	    // float **tmp = new float*[simple_potentials.size()];
< 	    for (int i=0; i < simple_potentials.size(); ++i) {
< 		const SimplePotential sp = simple_potentials[i];
< 		gpuErrchk(cudaMalloc(&val[i], sizeof(float)*sp.size));
< 		gpuErrchk(cudaMemcpyAsync(val[i], sp.pot, sizeof(float)*sp.size, cudaMemcpyHostToDevice));
< 		// tmp[i] = sp.pot;
< 		// // sp.pot = val[i];
< 	    }
< 
< 	    // size_t sz =  sizeof(SimplePotential) * simple_potentials.size();
< 	    // gpuErrchk(cudaMalloc(&simple_potentials_d, sz));
< 	    // gpuErrchk(cudaMemcpyAsync(simple_potentials_d, &simple_potentials[0], sz,
< 	    // 				  cudaMemcpyHostToDevice));
< 	    
< 	    // for (int i=0; i < simple_potentials.size(); ++i) { // Restore host pointers on host object
< 	    // 	SimplePotential &sp = simple_potentials[i];
< 	    // 	sp.pot = tmp[i];
< 	    // }
< 	    // // delete[] val;
< 	    // delete[] tmp;
< 
< 	}
< 	
< 	if (numProductPotentials > 0) {
< 	    // Count particles
< 	    int n_pots = 0;
< 	    int n_particles = 0;
< 	    for (int i=0; i < numProductPotentials; ++i) {
< 		const ProductPotentialConf& c = product_potential_confs[i];
< 		n_pots += c.indices.size();
< 		for (int j=0; j < c.indices.size(); ++j) {
< 		    n_particles += c.indices[j].size();
< 		}
< 	    }
< 	    // printf("DEBUG: Found %d particles participating in %d potentials forming %d productPotentials\n",
< 	    // 	   n_particles, n_pots, numProductPotentials);
< 
< 	    // Build productPotentialLists on host
< 	    int *particle_list = new int[n_particles*numReplicas];
< 	    SimplePotential *product_potentials = new SimplePotential[n_pots];
< 	    uint2 *product_potential_list = new uint2[numProductPotentials*numReplicas];
< 	    unsigned short *productCount = new unsigned short[numProductPotentials*numReplicas];
< 
< 	    n_particles = 0;
< 	    
< 	    for (unsigned int r=0; r < numReplicas; ++r) {
< 		n_pots = 0;
< 		for (int i=0; i < numProductPotentials; ++i) {
< 		    const ProductPotentialConf& c = product_potential_confs[i];
< 		    product_potential_list[i+r*numProductPotentials] = make_uint2( n_pots, n_particles );
< 
< 		    for (int j=0; j < c.indices.size(); ++j) {
< 			if (r == 0) {
< 			    const unsigned int sp_i = simple_potential_map.find( std::string( c.potential_names[j].val() ) )->second;
< 			    product_potentials[n_pots] = simple_potentials[sp_i];
< 			    product_potentials[n_pots].pot = simple_potential_pots_d[sp_i];
< 			}
< 			++n_pots;
< 			for (int k=0; k < c.indices[j].size(); ++k) {
< 			    particle_list[n_particles++] = c.indices[j][k]+r*num;
< 			}
< 		    }
< 		    productCount[i+r*numProductPotentials] = c.indices.size();
< 		}
< 	    }
< 
< 	    // Copy to device
< 	    size_t sz = n_particles*numReplicas * sizeof(int);
< 	    gpuErrchk(cudaMalloc(&product_potential_particles_d, sz));
< 	    gpuErrchk(cudaMemcpyAsync(product_potential_particles_d, particle_list, sz,
< 	    				  cudaMemcpyHostToDevice));
< 	    sz = n_pots * sizeof(SimplePotential);
< 	    gpuErrchk(cudaMalloc(&product_potentials_d, sz));
< 	    gpuErrchk(cudaMemcpyAsync(product_potentials_d, product_potentials, sz,
< 	    				  cudaMemcpyHostToDevice));
< 	    sz = numProductPotentials*numReplicas * sizeof(uint2);
< 	    gpuErrchk(cudaMalloc(&product_potential_list_d, sz));
< 	    gpuErrchk(cudaMemcpyAsync(product_potential_list_d, product_potential_list, sz,
< 	    				  cudaMemcpyHostToDevice));
< 	    sz = numProductPotentials*numReplicas * sizeof(unsigned short);
< 	    gpuErrchk(cudaMalloc(&productCount_d, sz));
< 	    gpuErrchk(cudaMemcpyAsync(productCount_d, productCount, sz,
< 	    				  cudaMemcpyHostToDevice));
< 
< 	    // Clean up
< 	    delete[] particle_list;
< 	    delete[] product_potentials;
< 	    delete[] product_potential_list;
< 	    delete[] productCount;
< 	}
< 
1082c957,959
< void ComputeForce::copyBondedListsToGPU(int3 *bondList, int4 *angleList, int4 *dihedralList, int *dihedralPotList, int4* bondAngleList, int2* restraintList) {
---
> void ComputeForce::copyBondedListsToGPU(int3 *bondList, int4 *angleList, int4 *dihedralList, int *dihedralPotList) {
> 
> 	
1106,1118d982
< 
< 	if (numBondAngles > 0) {
< 	    size = 2*numBondAngles * numReplicas * sizeof(int4);
< 	    gpuErrchk( cudaMalloc( &bondAngleList_d, size ) );
< 	    gpuErrchk( cudaMemcpyAsync( bondAngleList_d, bondAngleList, size, cudaMemcpyHostToDevice) );
< 	}
< 
< 	if (numRestraints > 0) {
< 	    size = numRestraints * numReplicas * sizeof(int2);
< 	    gpuErrchk( cudaMalloc( &restraintList_d, size ) );
< 	    gpuErrchk( cudaMemcpyAsync( restraintList_d, restraintList, size, cudaMemcpyHostToDevice) );
< 	}
< 
diff src/ComputeForce.cuh /data/server2/pinyili2/arbd_software/arbd.after_server5/src/ComputeForce.cuh
6d5
< 
8d6
< 
870,955d867
< __global__
< void computeTabulatedBondAngles(Vector3* force,
< 				Vector3* __restrict__ pos,
< 				BaseGrid* __restrict__ sys,
< 				int numBondAngles, int4* __restrict__ bondAngleList_d, TabulatedAnglePotential** tableAngle,
< 				TabulatedPotential** tableBond,
< 				float* energy, bool get_energy) {
< 	// Loop over ALL angles in ALL replicas
< 	for (int i = threadIdx.x+blockIdx.x*blockDim.x; i<numBondAngles; i+=blockDim.x*gridDim.x) {
< 		int atom1 = bondAngleList_d[2*i].x;
< 		int atom2 = bondAngleList_d[2*i].y;
< 		int atom3 = bondAngleList_d[2*i].z;
< 		int atom4 = bondAngleList_d[2*i].w;
< 
< 		int angleInd1 = bondAngleList_d[2*i+1].x;
< 		int bondInd   = bondAngleList_d[2*i+1].y;
< 		int angleInd2 = bondAngleList_d[2*i+1].z;
< 
< 		computeBondAngle(tableAngle[ angleInd1 ], tableBond[ bondInd ], tableAngle[ angleInd2 ], sys, force, pos, atom1, atom2, atom3, atom4, energy, get_energy);
< 	}
< }
< 
< __global__
< void computeProductPotentials(Vector3* force,
< 			      Vector3* __restrict__ pos,
< 			      BaseGrid* __restrict__ sys,
< 			      int numProductPotentials,
< 			      int* __restrict__ productPotentialParticles,
< 			      SimplePotential* __restrict__ potentialList,
< 			      uint2* __restrict__ productPotential_list,
< 			      unsigned short* __restrict__ productCount,
< 			      float* energy, bool get_energy) {
<     /*
<       productPotential_list[i].x : index of first potential in potentialList for i_th productPotential
<       productPotential_list[i].y : index of first atom in productPotentialParticles for i_th productPotential
< 
<       for three potentials, angle, bond, angle, we would have the following atomic indices in productPotentialParticles:
<         pot1 : productPotential_list[i].y, productPotential_list[i].y + 1 , productPotential_list[i].y + 2
<         pot2 : productPotential_list[i].y + 3, productPotential_list[i].y + 4
< 	and
<         pot3 : productPotential_list[i].y + 5, productPotential_list[i].y + 6, productPotential_list[i].y + 7
< 
<       productCount[i] : number of potentials in the i_th productPotential
<     */
< 
<     // CRAPPY NAIVE IMPLEMENTATION
<     constexpr int MAX_XPOTS = 4;
<     float2 energy_and_deriv[MAX_XPOTS];
<     float tmp_force;
< 
<     for (int i = threadIdx.x+blockIdx.x*blockDim.x; i<numProductPotentials; i+=blockDim.x*gridDim.x) {
< 	unsigned short num_pots = productCount[i];
< 
< 	unsigned int part_idx = productPotential_list[i].y;
< #pragma unroll
< 	for (unsigned short int j = 0; j < MAX_XPOTS; ++j) {
< 	    if (j == num_pots) break;
< 	    SimplePotential& p = potentialList[ productPotential_list[i].x + j ];
< 
< 	    // Hidden branch divergence in compute_value => sort potentials by type before running kernel
< 	    float tmp = p.compute_value(pos,sys, &productPotentialParticles[part_idx]);
< 	    energy_and_deriv[j] = p.compute_energy_and_deriv(tmp);
< 	    part_idx += p.type==BOND? 2: p.type==ANGLE? 3: 4;
< 	}
< 
< 	part_idx = productPotential_list[i].y;
< #pragma unroll
< 	for (unsigned short int j = 0; j < MAX_XPOTS; ++j) {
< 	    if (j == num_pots) break;
< 	    tmp_force = energy_and_deriv[j].y;
< #pragma unroll
< 	    for (unsigned short int k = 0; k < MAX_XPOTS; ++k) {
< 		if (k == num_pots) break;
< 		if (j == k) continue;
< 		tmp_force *= energy_and_deriv[k].x;
< 	    }
< 	    SimplePotential& p = potentialList[ productPotential_list[i].x + j ];
< 	    if (tmp_force != 0) {
< 		// TODO add energy
< 		p.apply_force(pos,sys, force, &productPotentialParticles[part_idx], tmp_force);
< 	    }
< 	    part_idx += p.type==BOND? 2: p.type==ANGLE? 3: 4;
< 	}
<     }
< }
< 
1071c983
< 			       int numRestraints, const int2* const __restrict__ restraintList,
---
> 			       int numRestraints, const int* const __restrict__ particleId,
1076,1080c988,990
< 	const int& id = restraintList[i].x;
< 	const int& rid = restraintList[i].y;
< 
< 	const Vector3 dr = sys->wrapDiff(pos[id]-r0[rid]);
< 	Vector3 f = -k[rid]*dr;
---
> 	const int& id = particleId[i];
> 	const Vector3 dr = sys->wrapDiff(pos[id]-r0[i]);
> 	Vector3 f = -k[i]*dr;
diff src/ComputeForce.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/ComputeForce.h
4c4,5
< #pragma once
---
> #ifndef COMPUTEFORCE_H
> #define COMPUTEFORCE_H
27d27
< #include "ProductPotential.h"
30,31d29
< // #include <map>
< 
37,54d34
< #ifdef USE_BOOST
< #include <boost/unordered_map.hpp>
< typedef boost::unordered_map<std::string,unsigned int> XpotMap;
< inline std::size_t hash_value(String const& s) {
<     if (s.length() == 0) return 0;
<     return boost::hash_range(s.val(), s.val()+s.length());
< }
< #else
< #include <map>
< typedef std::map<std::string,unsigned int> XpotMap;
< inline std::size_t hash_value(String const& s) {
<     if (s.length() == 0) return 0;
<     return std::hash<std::string>{}( std::string(s.val()) );
< }
< #endif
< 
< 
< 
69,70c49,50
< 	bool addBondPotential(String fileName, int ind, Bond* bonds, BondAngle* bondAngles);
< 	bool addAnglePotential(String fileName, int ind, Angle* angles, BondAngle* bondAngles);
---
> 	bool addBondPotential(String fileName, int ind, Bond* bonds);
> 	bool addAnglePotential(String fileName, int ind, Angle* angles);
98,101c78
< 	void copyToCUDA(int simNum, int *type, Bond* bonds, int2* bondMap, Exclude* excludes, int2* excludeMap, Angle* angles, Dihedral* dihedrals, const Restraint* const restraints, const BondAngle* const bondAngles,
< 			const XpotMap simple_potential_map,
< 			const std::vector<SimplePotential> simple_potentials,
< 			const ProductPotentialConf* const product_potential_confs);
---
> 	void copyToCUDA(int simNum, int *type, Bond* bonds, int2* bondMap, Exclude* excludes, int2* excludeMap, Angle* angles, Dihedral* dihedrals, const Restraint* const restraints);
106c83
<     void copyBondedListsToGPU(int3 *bondList, int4 *angleList, int4 *dihedralList, int *dihedralPotList, int4 *bondAngleList, int2 *restraintList);
---
> 	void copyBondedListsToGPU(int3 *bondList, int4 *angleList, int4 *dihedralList, int *dihedralPotList);
174d150
< 	const size_t tot_num = (num+num_rb_attached_particles+numGroupSites) * numReplicas;
177c153
< 	    gpuErrchk(cudaMemsetAsync((void*)(forceInternal_d[i]),0,tot_num*sizeof(Vector3)));
---
> 	    gpuErrchk(cudaMemsetAsync((void*)(forceInternal_d[i]),0,(num+numGroupSites)*numReplicas*sizeof(Vector3)));
182,183c158
< 	const size_t tot_num = (num+num_rb_attached_particles+numGroupSites) * numReplicas;
< 	gpuErrchk(cudaMemsetAsync((void*)(energies_d), 0, sizeof(float)*tot_num)); // TODO make async
---
> 	gpuErrchk(cudaMemsetAsync((void*)(energies_d), 0, sizeof(float)*(num+numGroupSites)*numReplicas)); // TODO make async
277,288d251
< 	int numBondAngles;
< 	BondAngle* bondAngles_d;
< 	int4* bondAngleList_d;
< 
<     int numProductPotentials;
<     float** simple_potential_pots_d;
<     SimplePotential* simple_potentials_d;
<     int* product_potential_particles_d;
<     SimplePotential* product_potentials_d;
<     uint2* product_potential_list_d;
<     unsigned short* productCount_d;
< 
293,294c256
<         int2* restraintList_d;
<     
---
> 
300,301d261
<     
< 
302a263,264
> 
> #endif
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: ComputeForce.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: ComputeGridGrid.o
diff src/Configuration.cpp /data/server2/pinyili2/arbd_software/arbd.after_server5/src/Configuration.cpp
5d4
< #include "ProductPotential.h"
138,148c137,144
< 	    for (size_t replica = 0; replica < simNum; ++replica) {
< 		int pidx = 0;
< 		for (int i = 0; i < numRigidTypes; i++) { // Loop over RB types
< 		    RigidBodyType &rbt = rigidBody[i];
< 		    for (int j = 0; j < rbt.num; ++j) { // Loop over RBs
< 			for (const int& t: rbt.get_attached_particle_types()) {
< 			    size_t _idx = num+pidx+replica*(num+num_rb_attached_particles);
< 			    type[_idx] = t;
< 			    serial[_idx] = num+pidx;
< 			    pidx++;
< 			}
---
> 	    int pidx = 0;
> 	    for (int i = 0; i < numRigidTypes; i++) { // Loop over RB types
> 		RigidBodyType &rbt = rigidBody[i];
> 		for (int j = 0; j < rbt.num; ++j) { // Loop over RBs
> 		    for (const int& t: rbt.get_attached_particle_types()) {
> 			type[num+pidx] = t;
> 			serial[num+pidx] = num+pidx;
> 			pidx++;
173,183d168
< 
< 		// Copy restart data to replicas
< 		for (size_t replica = 1; replica < simNum; ++replica) {
< 		    for (size_t i = 0; i < num; ++i) {
< 			size_t _idx = i+replica*(num+num_rb_attached_particles);
< 			type[_idx] = type[i];
< 			serial[_idx] = serial[i];
< 			pos[_idx] = pos[i];
< 		    }
< 		}
< 
226c211
< 				    type[i + s*(num+num_rb_attached_particles)] = currType;
---
> 				    type[i + s*num] = currType;
289,291d273
< 	if (readBondAnglesFromFile) readBondAngles();
< 	if (readProductPotentialsFromFile) readProductPotentials();
< 
365,370d346
< 	std::map<std::string,float> grid_mean_dict;
< 	for (const auto& pair : part_grid_dictionary)
< 	{
< 	    grid_mean_dict.insert({pair.first, pair.second.mean()});
< 	}
< 
381c357
< 		part[i].meanPmf[j] = grid_mean_dict.find( std::string(partGridFile[i][j]) )->second * part[i].pmf_scale[j];
---
> 		part[i].meanPmf[j] = part[i].pmf[j]->mean(); // TODO: review how this is used and decide whether to scale
385d360
< 			if (partForceGridScale[i] != nullptr) part[i].forceXGrid->scale( partForceGridScale[i][0] );
392d366
< 			if (partForceGridScale[i] != nullptr) part[i].forceYGrid->scale( partForceGridScale[i][1] );
401,404d374
< 			if (partForceGridScale[i] != nullptr) {
< 			    printf("Scaling forceGridZ `%s' by %f.\n", partForceZGridFile[i].val(), partForceGridScale[i][2] );
< 			    part[i].forceZGrid->scale( partForceGridScale[i][2] );
< 			}
663,664d632
< 	if (bondAngles != NULL) delete[] bondAngles;
< 	if (productPotentials != NULL) delete[] productPotentials;
764,774d731
< 		// Copy the diffusion grid
< 		if (part[i].forceXGrid != nullptr) {
< 		    b->forceXGrid = part[i].forceXGrid->copy_to_cuda();
< 		}
< 		if (part[i].forceYGrid != nullptr) {
< 		    b->forceYGrid = part[i].forceYGrid->copy_to_cuda();
< 		}
< 		if (part[i].forceZGrid != nullptr) {
< 		    b->forceZGrid = part[i].forceZGrid->copy_to_cuda();
< 		}
< 
907,916d863
< 	readBondAnglesFromFile = false;
< 	numBondAngles = 0;
< 	bondAngles = NULL;
< 
< 	readProductPotentialsFromFile = false;
< 	numProductPotentials = 0;
< 	productPotentials = NULL;
< 	simple_potential_ids = XpotMap();
< 	simple_potentials = std::vector<SimplePotential>();
< 
956,957d902
<         partForceGridScale  = new float*[numParts];
< 
980d924
<             partForceGridScale[i] = nullptr;
1108,1115d1051
< 		} else if (param == String("forceGridScale")) {
< 		    if (currPart < 0) exit(1);
< 		    int tmp;
< 		    stringToArray<float>(&value, tmp, &partForceGridScale[currPart]);
< 		    if (tmp != 3) {
< 			printf("ERROR: Expected three floating point scale values for x,y,z, but got `%s'.\n", param.val());
< 			exit(1);
< 		    }
1189,1202d1124
< 		} else if (param == String("inputBondAngles")) {
< 			if (readBondAnglesFromFile) {
< 				printf("WARNING: More than one bondangle file specified. Ignoring new bondangle file.\n");
< 			} else {
< 			        bondAngleFile = value;
< 				readBondAnglesFromFile = true;
< 			}
< 		} else if (param == String("inputProductPotentials")) {
< 			if (readBondAnglesFromFile) {
< 				printf("WARNING: More than one product potential file specified. Ignoring new file.\n");
< 			} else {
< 			        productPotentialFile = value;
< 				readProductPotentialsFromFile = true;
< 			}
1288c1210,1216
< 		} else if (param == String("attachedParticles")) {
---
>                 } else if (param == String("constantTorque"))
>                         rigidBody[currRB].constantTorque = stringToVector3( value );
>                 else if (param == String("constantForce"))
>                         rigidBody[currRB].constantForce = stringToVector3( value );
>                 else if (param == String("vectorTorque"))
>                         rigidBody[currRB].vectorTorque = stringToVector3( value );
> 		else if (param == String("attachedParticles"))
1290c1218
< 		} else if (param == String("densityGrid")) {
---
> 		else if (param == String("densityGrid")) {
1686c1614
< 
---
> 		      
2006,2177d1933
< void Configuration::readBondAngles() {
< 	FILE* inp = fopen(bondAngleFile.val(), "r");
< 	char line[256];
< 	int capacity = 256;
< 	numBondAngles = 0;
< 	bondAngles = new BondAngle[capacity];
< 
< 	// If the angle file cannot be found, exit the program
< 	if (inp == NULL) {
< 		printf("WARNING: Could not open `%s'.\n", bondAngleFile.val());
< 		printf("This simulation will not use angles.\n");
< 		return;
< 	}
< 
< 	while(fgets(line, 256, inp)) {
< 		if (line[0] == '#') continue;
< 		String s(line);
< 		int numTokens = s.tokenCount();
< 		String* tokenList = new String[numTokens];
< 		s.tokenize(tokenList);
< 
< 		// Legitimate BONDANGLE inputs have 8 tokens
< 		// BONDANGLE | INDEX1 | INDEX2 | INDEX3 | INDEX4 | ANGLE_FILENAME | BOND_FILENAME1 | BOND_FILENAME2
< 		if (numTokens != 8) {
< 			printf("WARNING: Invalid bond_angle input line: %s\n", line);
< 			continue;
< 		}
< 
< 		// Discard any empty line
< 		if (tokenList == NULL)
< 			continue;
< 
< 		int ind1 = atoi(tokenList[1].val());
< 		int ind2 = atoi(tokenList[2].val());
< 		int ind3 = atoi(tokenList[3].val());
< 		int ind4 = atoi(tokenList[4].val());
< 		String file_name1 = tokenList[5];
< 		String file_name2 = tokenList[6];
< 		String file_name3 = tokenList[7];
< 		//printf("file_name %s\n", file_name.val());
< 		if (ind1 >= num or ind2 >= num or ind3 >= num or ind4 >= num)
< 			continue;
< 
< 		if (numBondAngles >= capacity) {
< 			BondAngle* temp = bondAngles;
< 			capacity *= 2;
< 			bondAngles = new BondAngle[capacity];
< 			for (int i = 0; i < numBondAngles; i++)
< 				bondAngles[i] = temp[i];
< 			delete[] temp;
< 		}
< 
< 		BondAngle a(ind1, ind2, ind3, ind4, file_name1, file_name2, file_name3);
< 		bondAngles[numBondAngles++] = a;
< 		delete[] tokenList;
< 	}
< 	std::sort(bondAngles, bondAngles + numBondAngles, compare());
< 
< 	// for(int i = 0; i < numAngles; i++)
< 	// 	angles[i].print();
< }
< 
< void Configuration::readProductPotentials() {
< 	FILE* inp = fopen(productPotentialFile.val(), "r");
< 	char line[256];
< 	int capacity = 256;
< 	numProductPotentials = 0;
< 	productPotentials = new ProductPotentialConf[capacity];
< 
< 	// If the angle file cannot be found, exit the program
< 	if (inp == NULL) {
< 		printf("WARNING: Could not open `%s'.\n", productPotentialFile.val());
< 		printf("This simulation will not use product potentials.\n");
< 		return;
< 	}
< 	printf("DEBUG: READING PRODUCT POTENTAL FILE\n");
< 	std::vector<std::vector<int>> indices;
< 	std::vector<int> tmp;
< 	std::vector<String> pot_names;
< 
< 	while(fgets(line, 256, inp)) {
< 		if (line[0] == '#') continue;
< 		String s(line);
< 		int numTokens = s.tokenCount();
< 		String* tokenList = new String[numTokens];
< 		s.tokenize(tokenList);
< 
< 		indices.clear();
< 		tmp.clear();
< 		pot_names.clear();		    
< 
< 		printf("\rDEBUG: reading line %d",numProductPotentials+1);
< 
< 		// Legitimate ProductPotential inputs have at least 7 tokens
< 		// BONDANGLE | INDEX1 | INDEX2 | INDEX3 | [TYPE1] | POT_FILENAME1 | INDEX4 | INDEX5 | [TYPE2] POT_FILENAME2 ...
< 		if (numTokens < 5) {
< 		    printf("WARNING: Invalid product potential input line (too few tokens %d): %s\n", numTokens, line);
< 			continue;
< 		}
< 
< 		// Discard any empty line
< 		if (tokenList == NULL)
< 			continue;
< 
< 		SimplePotentialType type = BOND; // initialize to suppress warning
< 		bool type_specified = false;
< 		for (int i = 1; i < numTokens; ++i) {
< 		    char *end;
< 		    // printf("DEBUG: Working on token %d '%s'\n", i, tokenList[i].val());
< 
< 		    // Try to convert token to integer
< 		    int index = (int) strtol(tokenList[i].val(), &end, 10);
< 		    if (tokenList[i].val() == end || *end != '\0' || errno == ERANGE) {
< 			// Failed to convert token to integer; therefore it must be a potential name or type
< 
< 			// Try to match a type
< 			String n = tokenList[i];
< 			n.lower();
< 			if (n == "bond") { type = ΒΟΝD; type_specified = true; }
< 			else if (n == "angle")  { type = ANGLE; type_specified = true; }
< 			else if (n == "dihedral")  { type = DIHEDRAL; type_specified = true; }
< 			else if (n == "vecangle") { type = VECANGLE; type_specified = true; }
< 			else { // Not a type, therefore a path to a potential
< 			    n = tokenList[i];
< 			    indices.push_back(tmp);
< 			    pot_names.push_back( n );
< 			    // TODO: Key should be tuple of (type,n)
< 			    std::string n_str = std::string(n.val());
< 			    if ( simple_potential_ids.find(n_str) == simple_potential_ids.end() ) {
< 				// Could not find fileName in dictionary, so read and add it
< 				unsigned int s = tmp.size();
< 				if (s < 2 || s > 4) {
< 				    printf("WARNING: Invalid product potential input line (indices of potential %d == %d): %s\n", i, s, line);
< 				    continue;
< 				}
< 				simple_potential_ids[ n_str ] = simple_potentials.size();
< 				if (not type_specified) type = s==2? BOND: s==3? ANGLE: DIHEDRAL;
< 				simple_potentials.push_back( SimplePotential(n.val(), type) );
< 			    }
< 			    tmp.clear();
< 			    type_specified = false;
< 
< 			}
< 		    } else {
< 			if (index >= num) {
< 			    continue;
< 			}
< 			tmp.push_back(index);
< 		    }
< 		}
< 
< 		if (numProductPotentials >= capacity) {
< 			ProductPotentialConf* temp = productPotentials;
< 			capacity *= 2;
< 			productPotentials = new ProductPotentialConf[capacity];
< 			for (int i = 0; i < numProductPotentials; i++)
< 				productPotentials[i] = temp[i];
< 			delete[] temp;
< 		}
< 
< 		ProductPotentialConf a(indices, pot_names);
< 		productPotentials[numProductPotentials++] = a;
< 		delete[] tokenList;
< 	}
< 	printf("\nDEBUG: Sorting\n");
< 	std::sort(productPotentials, productPotentials + numProductPotentials, compare());
< 
< 	// for(int i = 0; i < numAngles; i++)
< 	// 	angles[i].print();
< }
< 
< 
2236,2248c1992,2004
< 	const int offset = repID * (num+num_rb_attached_particles);
< 	int pn = 0;
< 	int p = 0;
< 	for (int i = 0; i < num; ++i) {
< 	    type[i + offset] = p;
< 	    serial[i + offset] = currSerial++;
< 
< 	    if (++pn >= part[p].num) {
< 		p++;
< 		pn = 0;
< 	    }
< 	}
<     }
---
>                 const int offset = repID * num;
>                 int pn = 0;
>                 int p = 0;
>                 for (int i = 0; i < num; ++i) {
>                         type[i + offset] = p;
>                         serial[i + offset] = currSerial++;
> 
>                         if (++pn >= part[p].num) {
>                                 p++;
>                                 pn = 0;
>                         }
>                 }
>         }
2776,2806d2531
< }
< 
< bool Configuration::compare::operator()(const BondAngle& lhs, const BondAngle& rhs) {
< 	int diff = lhs.ind1 - rhs.ind1;
< 	if (diff != 0)
< 		return lhs.ind1 < rhs.ind1;
< 	diff = lhs.ind2 - rhs.ind2;
< 	if (diff != 0)
< 		return lhs.ind2 < rhs.ind2;
< 	diff = lhs.ind3 - rhs.ind3;
< 	if (diff != 0) 
< 		return lhs.ind3 < rhs.ind3;
< 	return lhs.ind4 < rhs.ind4;
< }
< 
< bool Configuration::compare::operator()(const ProductPotentialConf& lhs, const ProductPotentialConf& rhs) {
<     int diff = rhs.indices.size() - lhs.indices.size();
<     if (diff != 0) return diff > 0;
< 
<     for (unsigned int i = 0; i < lhs.indices.size(); ++i) {
< 	diff = rhs.indices[i].size() - lhs.indices[i].size();
< 	if (diff != 0) return diff > 0;
<     }
< 
<     for (unsigned int i = 0; i < lhs.indices.size(); ++i) {
< 	for (unsigned int j = 0; j < lhs.indices[i].size(); ++j) {
< 	    diff = rhs.indices[i][j] - lhs.indices[i][j];
< 	    if (diff != 0) return diff > 0;
< 	}
<     }
<     return true;
diff src/Configuration.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/Configuration.h
28d27
< #include "ProductPotential.h"
52,53d50
< 		bool operator()(const BondAngle& lhs, const BondAngle& rhs);
< 		bool operator()(const ProductPotentialConf& lhs, const ProductPotentialConf& rhs);
70d66
< 	void readBondAngles();
78,79d73
< 	bool readBondAngleFile(const String& value, const String& bondfile1, const String& bondfile2, int currBondAngle);
< 
210d203
< 	int numBondAngles;
219d211
< 	String bondAngleFile;
226d217
< 	bool readBondAnglesFromFile;
240d230
< 	float **partForceGridScale;
267,268d256
< 	BondAngle* bondAngles;
< 
270,277d257
< 
< 	void readProductPotentials();
< 	String productPotentialFile;
< 	int numProductPotentials;
< 	bool readProductPotentialsFromFile;
<         ProductPotentialConf* productPotentials;
< 	XpotMap simple_potential_ids;
<         std::vector<SimplePotential> simple_potentials;
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Configuration.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: CudaUtil.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Dihedral.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Exclude.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: FlowForce.o
diff src/GPUManager.cpp /data/server2/pinyili2/arbd_software/arbd.after_server5/src/GPUManager.cpp
21,23d20
< #ifndef CUDART_VERSION
< #error CUDART_VERSION Undefined!
< #elif (CUDART_VERSION < 12000)
25,27d21
< #else
<     cudaGetDeviceProperties_v2(&properties, id);
< #endif
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: GPUManager.o
diff src/GrandBrownTown.cu /data/server2/pinyili2/arbd_software/arbd.after_server5/src/GrandBrownTown.cu
207,208d206
< 	numBondAngles = c.numBondAngles;
< 
225,226d222
< 	bondAngles = c.bondAngles;
< 
263c259
< 
---
> 	
265c261
< 	internal -> copyToCUDA(c.simNum, c.type, c.bonds, c.bondMap, c.excludes, c.excludeMap, c.angles, c.dihedrals, c.restraints, c.bondAngles, c.simple_potential_ids, c.simple_potentials, c.productPotentials );
---
> 	internal -> copyToCUDA(c.simNum, c.type, c.bonds, c.bondMap, c.excludes, c.excludeMap, c.angles, c.dihedrals, c.restraints);
290c286
< 			    internal->addBondPotential(bondTableFile[p].val(), p, bonds, bondAngles);
---
> 				internal->addBondPotential(bondTableFile[p].val(), p, bonds);
294c290
< 			    internal->addBondPotential(bondTableFile[p].val(), p, bonds, bondAngles);
---
> 			    internal->addBondPotential(bondTableFile[p].val(), p, bonds);
305c301
< 			    internal->addAnglePotential(angleTableFile[p].val(), p, angles, bondAngles);
---
> 				internal->addAnglePotential(angleTableFile[p].val(), p, angles);
380,426c376
< 
< 	if (numBondAngles > 0) {
< 	bondAngleList = new int4[ (numBondAngles*2) * numReplicas ];
< 	for(int k = 0 ; k < numReplicas; k++) {
< 	    for(int i = 0; i < numBondAngles; ++i) {
< 			if (bondAngles[i].tabFileIndex1 == -1) {
< 				fprintf(stderr,"Error: bondanglefile '%s' was not read with tabulatedAngleFile command.\n", bondAngles[i].angleFileName1.val());
< 				exit(1);
< 			}
< 			if (bondAngles[i].tabFileIndex2 == -1) {
< 				fprintf(stderr,"Error: bondanglefile1 '%s' was not read with tabulatedBondFile command.\n", bondAngles[i].bondFileName.val());
< 				exit(1);
< 			}
< 			if (bondAngles[i].tabFileIndex3 == -1) {
< 				fprintf(stderr,"Error: bondanglefile2 '%s' was not read with tabulatedBondFile command.\n", bondAngles[i].angleFileName2.val());
< 				exit(1);
< 			}
< 			int idx = i+k*numBondAngles;
< 			bondAngleList[idx*2]   = make_int4( _get_index(bondAngles[i].ind1,k),
< 							    _get_index(bondAngles[i].ind2,k),
< 							    _get_index(bondAngles[i].ind3,k),
< 							    _get_index(bondAngles[i].ind4,k) );
< 			bondAngleList[idx*2+1] = make_int4( bondAngles[i].tabFileIndex1, bondAngles[i].tabFileIndex2, bondAngles[i].tabFileIndex3, -1 );
< 	    }
< 	}
< 	}
< 
< 	// TODO: remove older copy-to-cuda
< 	int2* restraintList = NULL;
< 	if (c.numRestraints > 0) {
< 	    restraintList = new int2[c.numRestraints * numReplicas];
< 	    int j = 0;
< 	    for(int k = 0 ; k < numReplicas; k++)
< 	    {
< 		for(int i = 0; i < c.numRestraints; ++i)
< 		{
< 		    restraintList[j] = make_int2( _get_index(c.restraints[i].id, k), i );
< 		    // cout << "Displaying: bondList["<< j <<"].x = " << bondList[j].x << ".\n"
< 		    // << "Displaying: bondList["<< j <<"].y = " << bondList[j].y << ".\n"
< 		    // << "Displaying: bondList["<< j <<"].z = " << bondList[j].z << ".\n";
< 		    ++j;
< 		}
< 	    }
< 	}
< 	
< 	internal->copyBondedListsToGPU(bondList,angleList,dihedralList,dihedralPotList,bondAngleList,restraintList);
< 	if (c.numRestraints > 0) delete[] restraintList;
---
> 	internal->copyBondedListsToGPU(bondList,angleList,dihedralList,dihedralPotList);
638a589,590
>     Vector3 *force_d;
>     gpuErrchk(cudaMalloc((void**)&force_d, sizeof(Vector3)*(num+num_rb_attached_particles+numGroupSites) * numReplicas));
649,655d600
< 
<     float kinetic_energy = 0.0f;
<     float potential_energy = 0.0f;
<     
<     bool get_energy = false;
<     bool print_energy = false;
<     
658a604
>         bool get_energy = ((s % outputEnergyPeriod) == 0);
678,680c624
< 	    gpuman.sync();
< 	    if (numGroupSites > 0) updateGroupSites<<<(numGroupSites*numReplicas/32+1),32>>>(_pos[0], groupSiteData_d, num + num_rb_attached_particles, numGroupSites, numReplicas);
< 	    gpuman.sync();
---
> 	    if (numGroupSites > 0) updateGroupSites<<<(numGroupSites/32+1),32>>>(_pos[0], groupSiteData_d, num + num_rb_attached_particles, numGroupSites, numReplicas);
685d628
< 		gpuman.sync();
687a631,633
> 	    gpuman.sync();
> 
> 
755,767c701,711
< 	    if (num_rb_attached_particles > 0) {
< 		if (get_energy) {
< 		    compute_position_dependent_force_for_rb_attached_particles
< 			<<< numBlocks, NUM_THREADS >>> (
< 			    internal -> getPos_d()[0],
< 			    internal -> getForceInternal_d()[0], internal -> getEnergy(),
< 			    internal -> getType_d(), part_d, electricField, num, num_rb_attached_particles, numReplicas, ParticleInterpolationType);
< 		} else {
< 		    compute_position_dependent_force_for_rb_attached_particles
< 			<<< numBlocks, NUM_THREADS >>> (
< 			    internal -> getPos_d()[0], internal -> getForceInternal_d()[0],
< 			    internal -> getType_d(), part_d, electricField, num, num_rb_attached_particles, numReplicas, ParticleInterpolationType);
< 		}
---
> 	    if (get_energy) {
> 		compute_position_dependent_force_for_rb_attached_particles
> 		    <<< numBlocks, NUM_THREADS >>> (
> 			internal -> getPos_d()[0], internal -> getForceInternal_d()[0],
> 			internal -> getType_d(), part_d, electricField, num, num_rb_attached_particles, numReplicas, ParticleInterpolationType);
> 	    } else {
> 		compute_position_dependent_force_for_rb_attached_particles
> 		    <<< numBlocks, NUM_THREADS >>> (
> 			internal -> getPos_d()[0],
> 			internal -> getForceInternal_d()[0], internal -> getEnergy(),
> 			internal -> getType_d(), part_d, electricField, num, num_rb_attached_particles, numReplicas, ParticleInterpolationType);
769a714
> 
800c745
< 	    if (numGroupSites > 0) distributeGroupSiteForces<false><<<(numGroupSites*numReplicas/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
---
> 	    if (numGroupSites > 0) distributeGroupSiteForces<false><<<(numGroupSites/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
803a749,750
> 	PUSH_NVTX("Clear particle energy data",1)
> 	internal->clear_energy();
804a752
> 	POP_NVTX
808,812c756
< 	    if (s == 1) {
< 		updateKernelBAOAB<true><<< numBlocks, NUM_THREADS >>>(internal->getPos_d()[0], internal->getMom_d(), internal->getForceInternal_d()[0], internal->getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d, randoGen_d, numReplicas, ParticleInterpolationType);
< 	    } else {
< 		updateKernelBAOAB<false><<< numBlocks, NUM_THREADS >>>(internal->getPos_d()[0], internal->getMom_d(), internal->getForceInternal_d()[0], internal->getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d, randoGen_d, numReplicas, ParticleInterpolationType);
< 	    }
---
>             updateKernelBAOAB<<< numBlocks, NUM_THREADS >>>(internal->getPos_d()[0], internal->getMom_d(), internal->getForceInternal_d()[0], internal->getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d, randoGen_d, numReplicas, ParticleInterpolationType);
815,819c759,761
< 	    if (s == 1) {
< 		updateKernelNoseHooverLangevin<true><<< numBlocks, NUM_THREADS >>>(internal -> getPos_d()[0], internal -> getMom_d(), internal -> getRan_d(), internal -> getForceInternal_d()[0], internal -> getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d, randoGen_d, numReplicas, ParticleInterpolationType);
< 	    } else {
< 		updateKernelNoseHooverLangevin<false><<< numBlocks, NUM_THREADS >>>(internal -> getPos_d()[0], internal -> getMom_d(), internal -> getRan_d(), internal -> getForceInternal_d()[0], internal -> getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d, randoGen_d, numReplicas, ParticleInterpolationType);
< 	    }
---
>             updateKernelNoseHooverLangevin<<< numBlocks, NUM_THREADS >>>(internal -> getPos_d()[0], internal -> getMom_d(), 
>             internal -> getRan_d(), internal -> getForceInternal_d()[0], internal -> getType_d(), part_d, kT, kTGrid_d, electricField, tl, timestep, num, num_rb_attached_particles, sys_d,
>             randoGen_d, numReplicas, ParticleInterpolationType);
960c902
< 	    updateGroupSites<<<(numGroupSites*numReplicas/32+1),32>>>(internal->getPos_d()[0], groupSiteData_d, num + num_rb_attached_particles, numGroupSites, numReplicas);
---
> 	    updateGroupSites<<<(numGroupSites/32+1),32>>>(internal->getPos_d()[0], groupSiteData_d, num + num_rb_attached_particles, numGroupSites, numReplicas);
965,986d906
< 	if (get_energy) {
< 	    PUSH_NVTX("Fetch particle energy data",1)
< 	    thrust::device_ptr<float> en_d(internal->getEnergy());
< 	    potential_energy = (thrust::reduce(en_d, en_d+(num+num_rb_attached_particles)*numReplicas)) / numReplicas;
< 	    if(particle_dynamic == String("Langevin") || particle_dynamic == String("NoseHooverLangevin"))
< 	    {
< 		gpuErrchk(cudaMemcpy(momentum, internal->getMom_d(), sizeof(Vector3)*num*numReplicas,cudaMemcpyDeviceToHost));
< 		kinetic_energy = KineticEnergy();
< 	    }
< 	    gpuman.sync();
< 	    POP_NVTX	
< 	}
< 	
< 	get_energy = (((s+1) % outputEnergyPeriod) == 0) || (((s+1) % outputPeriod) == 0);
< 	print_energy = ((s % outputEnergyPeriod) == 0);
< 
< 	if (get_energy) {
< 	    PUSH_NVTX("Clear particle energy data",1)
< 	    internal->clear_energy();
< 	    POP_NVTX	
< 	}
< 	    
990c910
< 	    PUSH_NVTX("Clear particle forces",2)
---
> 	  PUSH_NVTX("Clear particle forces",2)
1078,1079c998
< 		    internal -> getPos_d()[0],
< 		    internal -> getForceInternal_d()[0], internal -> getEnergy(),
---
> 		    internal -> getPos_d()[0], internal -> getForceInternal_d()[0],
1084c1003,1004
< 		    internal -> getPos_d()[0], internal -> getForceInternal_d()[0],
---
> 		    internal -> getPos_d()[0],
> 		    internal -> getForceInternal_d()[0], internal -> getEnergy(),
1105c1025
< 	    distributeGroupSiteForces<false><<<(numGroupSites*numReplicas/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
---
> 	    distributeGroupSiteForces<true><<<(numGroupSites/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
1107c1027
< 	//     distributeGroupSiteForces<false><<<(numGroupSites*numReplicas/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
---
> 	//     distributeGroupSiteForces<false><<<(numGroupSites/32+1),32>>>(internal->getForceInternal_d()[0], groupSiteData_d, num+num_rb_attached_particles, numGroupSites, numReplicas);
1169c1089
<         if (print_energy)
---
>         if (get_energy)
1182a1103,1105
>         //}
>         //if (get_energy)
>         //{
1185a1109,1117
>                 float e = 0.f;
>                 float V = 0.f;
>                 thrust::device_ptr<float> en_d(internal->getEnergy());
>                 V = (thrust::reduce(en_d, en_d+(num+num_rb_attached_particles)*numReplicas)) / numReplicas;
>                 if(particle_dynamic == String("Langevin") || particle_dynamic == String("NoseHooverLangevin"))
>                 {
>                     gpuErrchk(cudaMemcpy(momentum, internal->getMom_d(), sizeof(Vector3)*num*numReplicas,cudaMemcpyDeviceToHost));
>                     e = KineticEnergy();
>                 }   
1190,1191c1122,1123
<                     energy_file << "Kinetic Energy: " << kinetic_energy*num*0.5f*(2.388458509e-1) << " (kT) "<< std::endl;
<                     energy_file << "Potential Energy: " << potential_energy << " (kcal/mol) " << std::endl;
---
>                     energy_file << "Kinetic Energy: " << e*num*0.5f*(2.388458509e-1) << " (kT) "<< std::endl;
>                     energy_file << "Potential Energy: " << V << " (kcal/mol) " << std::endl;
1285a1218
>      gpuErrchk(cudaFree(force_d));
1439a1373
>     assert(numReplicas == 1);    // TODO make this work for replicas
diff src/GrandBrownTown.cuh /data/server2/pinyili2/arbd_software/arbd.after_server5/src/GrandBrownTown.cuh
64d63
< template <bool need_position_dep_force = false>
76,81c75,77
< 	ForceEnergy fe;
< 	if (need_position_dep_force) {
< 	    fe = compute_position_dependent_force(
< 		pos, forceInternal, type, part, electricField, scheme, idx );
< 	}
< 	
---
> 	ForceEnergy fe = compute_position_dependent_force(
> 	    pos, forceInternal, type, part, electricField, scheme, idx );
> 
89,92c85
< 	if (need_position_dep_force) {
< 	    forceInternal[idx] = forceInternal[idx] + fe.f;
< 	}
<         Vector3 force = forceInternal[idx];
---
>         Vector3 force = forceInternal[idx] + fe.f;
162d154
< template <bool need_position_dep_force = false>
176,180c168,169
< 	ForceEnergy fe;
< 	if (need_position_dep_force) {
< 	    fe = compute_position_dependent_force(
< 		pos, forceInternal, type, part, electricField, scheme, idx );
< 	}
---
> 	ForceEnergy fe = compute_position_dependent_force(
> 	    pos, forceInternal, type, part, electricField, scheme, idx );
188,192c177
< 	if (need_position_dep_force) { // only needed at ts == 1
< 	    forceInternal[idx] = forceInternal[idx] + fe.f;
< 	}
< 	Vector3 force = forceInternal[idx];
< 	
---
>         Vector3 force = forceInternal[idx] + fe.f;
267d251
<         forceInternal[idx] = forceInternal[idx] + fe.f; // Adding position-dep force so it doesn't need to be calculated in the "plain" kernel 
426d409
< template<bool print=false>
452,454c435
< 	if (print) {
< 	    printf("GroupSite %d (rep %d/%d) COM (start,finish, x,y,z): (%d,%d, %f,%f,%f)\n",i, rep, numReplicas, start, finish, tmp.x, tmp.y, tmp.z);
< 	}
---
> 	// printf("GroupSite %d (mod %d) COM (start,finish, x,y,z): (%d,%d, %f,%f,%f)\n",i, imod, start, finish, tmp.x, tmp.y, tmp.z);
459c440
< template<bool print=false>
---
> template<bool print>
474,476c455,457
< 	if (print) {
< 	    printf("GroupSite %d Force rep %d/%d: %f %f %f\n",i, rep, numReplicas, tmp.x, tmp.y, tmp.z);
< 	}
---
> 	// if (print) {
> 	//     printf("GroupSite %d Force rep %d: %f %f %f\n",i, rep, tmp.x, tmp.y, tmp.z);
> 	// }
diff src/GrandBrownTown.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/GrandBrownTown.h
278,281d277
< 	int numBondAngles;
< 	BondAngle* bondAngles;
< 	int4 *bondAngleList;
< 
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: GrandBrownTown.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: JamesBond.o
Only in src: ProductPotential.h
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: RandomCUDA.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Reservoir.o
diff src/RigidBodyController.cu /data/server2/pinyili2/arbd_software/arbd.after_server5/src/RigidBodyController.cu
398c398
< 		printf("Assigning positions %d %d %f\n",i,j, (float) strtod(tokenList[2],NULL));
---
> 		printf("Assinging positions %d %d %f\n",i,j, (float) strtod(tokenList[2],NULL));
578a579,580
>                         rb.addTorque(rb.t -> constantTorque);
>                         rb.addForce(rb.t -> constantForce);
943c945
< void RigidBodyController::print(long int step) {
---
> void RigidBodyController::print(int step) {
1026c1028
< void RigidBodyController::printData(long int step, std::ofstream &file) {
---
> void RigidBodyController::printData(int step,std::ofstream &file) {
diff src/RigidBodyController.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/RigidBodyController.h
116c116
<         void print(long int step);
---
>         void print(int step);
126c126
< 	void printData(long int step, std::ofstream &file);
---
> 	void printData(int step, std::ofstream &file);
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: RigidBodyController.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: RigidBodyGrid.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: RigidBody.o
diff src/RigidBodyType.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/RigidBodyType.h
28c28
< 		rotDamping(), initPos(), initRot(Matrix3(1.0f)), initMomentum(Vector3(0.f)), initAngularMomentum(Vector3(0.f)),
---
> 		rotDamping(), constantTorque(Vector3(0.f)),constantForce(Vector3(0.f)),initPos(), initRot(Matrix3(1.0f)), initMomentum(Vector3(0.f)), initAngularMomentum(Vector3(0.f)),
79a80,82
>         Vector3 constantTorque;
>         Vector3 constantForce;
>         Vector3 vectorTorque; 
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: RigidBodyType.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: Scatter.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: SignalManager.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: TabulatedAngle.o
diff src/TabulatedDihedral.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/TabulatedDihedral.h
15a16,17
> constexpr float BD_PI = 3.1415927f;
> 
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: TabulatedDihedral.o
diff src/TabulatedMethods.cuh /data/server2/pinyili2/arbd_software/arbd.after_server5/src/TabulatedMethods.cuh
5,12d4
< struct AngleForce {
<     __host__ __device__
<     AngleForce(Vector3 f1, Vector3 f3, float e) : f1(f1), f3(f3), e(e) { }
<     Vector3 f1;
<     Vector3 f3;
<     float e;
< };
< 
86,187d77
< }
< 
< __device__ inline AngleForce calcAngle(const TabulatedAnglePotential* __restrict__ a, const Vector3 ab, const Vector3 bc, const Vector3 ac) {
< 	// // The vectors between each pair of particles
< 	// const Vector3 ab = sys->wrapDiff(posa - posb);
< 	// const Vector3 bc = sys->wrapDiff(posb - posc);
< 	// const Vector3 ac = sys->wrapDiff(posc - posa);
<  
< 	// Find the distance between each pair of particles
< 	float distab = ab.length2();
< 	float distbc = bc.length2();
< 	const float distac2 = ac.length2();
<   
< 	// Find the cosine of the angle we want - <ABC	
< 	float cos = (distab + distbc - distac2);
< 
< 	distab = 1.0f/sqrt(distab); //TODO: test other functiosn
< 	distbc = 1.0f/sqrt(distbc);
< 	cos *= 0.5f * distbc * distab;
<   
< 	// If the cosine is illegitimate, set it to 1 or -1 so that acos won't fail
< 	if (cos < -1.0f) cos = -1.0f;
< 	if (cos > 1.0f) cos = 1.0f;
< 
< 	// Find the sine while we're at it.
< 
< 	// Now we can use the cosine to find the actual angle (in radians)		
< 	float angle = acos(cos);
< 
< 	// transform angle to units of tabulated array index
< 	angle *= a->angle_step_inv;
< 
< 	// tableAngle[0] stores the potential at angle_step
< 	// tableAngle[1] stores the potential at angle_step * 2, etc.
< 	// 'home' is the index after which 'convertedAngle' would appear if it were stored in the table	
< 	int home = int(floorf(angle));
<         home =  (home >= a->size) ? (a->size)-1 : home; 
< 	//assert(home >= 0);
< 	//assert(home+1 < a->size);
< 
< 	// // Make angle the distance from [0,1) from the first index in the potential array index
< 	// angle -= home;
< 		
< 	// Linearly interpolate the potential	
< 	float U0 = a->pot[home];
< 	float dUdx = (a->pot[(((home+1)==(a->size)) ? (a->size)-1 : home+1)] - U0) * a->angle_step_inv;
< 	float e = ((dUdx * (angle-home)) + U0);
< 
< 	float sin = sqrtf(1.0f - cos*cos);
< 	dUdx /= abs(sin) > 1e-3 ? sin : 1e-3; // avoid singularity 
< 
< 	// Calculate the forces
< 	Vector3 force1 = -(dUdx*distab) * (ab * (cos*distab) + bc * distbc); // force on particle 1
< 	Vector3 force3 = (dUdx*distbc) * (bc * (cos*distbc) + ab * distab); // force on particle 3
< 
< 	return AngleForce(force1,force3,e);
< }
< 
< __device__ inline void computeBondAngle(const TabulatedAnglePotential* __restrict__ a1,
< 					const TabulatedPotential* __restrict__ b, const TabulatedAnglePotential* __restrict__ a2,
< 					const BaseGrid* __restrict__ sys, Vector3* force, const Vector3* __restrict__ pos,
< 					const int& i, const int& j, const int& k, const int& l, float* energy, bool get_energy) {
< 
< 	// Particle's type and position
< 	Vector3 posa = pos[i];
< 	Vector3 posb = pos[j];
< 	Vector3 posc = pos[k];
< 	Vector3 posd = pos[l];
< 
< 	// The vectors between each pair of particles
< 	const Vector3 ab = sys->wrapDiff(posb - posa);
< 	const Vector3 bc = sys->wrapDiff(posc - posb);
< 	const Vector3 ca = sys->wrapDiff(posc - posa);
< 	AngleForce fe_a1 = calcAngle(a1, -ab,-bc,ca);
< 
< 	float distbc = bc.length2();
< 	EnergyForce fe_b = b->compute(bc,distbc);
< 
< 	const Vector3 cd = sys->wrapDiff(posd - posc);
< 	const Vector3 db = sys->wrapDiff(posd - posb);
< 	AngleForce fe_a2 = calcAngle(a2, -bc,-cd,db);
< 
<         if(get_energy)
<         {
< 	    float e =  fe_a1.e * fe_b.e * fe_a2.e * 0.25f;
<             atomicAdd( &energy[i], e);
<             atomicAdd( &energy[j], e);
<             atomicAdd( &energy[k], e);
<             atomicAdd( &energy[l], e);
<         }
< 	atomicAdd( &force[i], fe_a1.f1 * fe_b.e * fe_a2.e );
< 	atomicAdd( &force[j], 
< 		   -(fe_a1.f1 + fe_a1.f3) * fe_b.e * fe_a2.e
< 		   + fe_b.f * fe_a1.e * fe_a2.e
< 		   + fe_a2.f1 * fe_b.e * fe_a1.e 
< 	    );
< 	atomicAdd( &force[k], 
< 		   fe_a1.f3 * fe_b.e * fe_a2.e
< 		   - fe_b.f * fe_a1.e * fe_a2.e 
< 		   - (fe_a2.f1 + fe_a2.f3) * fe_b.e * fe_a1.e
< 	    );
< 	atomicAdd( &force[l], fe_a2.f3 * fe_b.e * fe_a1.e );
diff src/TabulatedPotential.cu /data/server2/pinyili2/arbd_software/arbd.after_server5/src/TabulatedPotential.cu
103,112d102
< // void TabulatedPotential::init(const float* dist, const float* pot, int n0) {
< // 	n = abs(n0);
< // 	dr = dist[1]-dist[0];
< // 	r0 = dist[0];
< // 	r1 = r0 + n*dr;
< 
< // 	v0 = new float[n];
< // 	for (int i = 0; i < n; i++) v0[i] = pot[i];
< // }
< 
192,260d181
< }
< 
< int countValueLines(const char* fileName) {
< 	FILE* inp = fopen(fileName, "r");
< 	if (inp == NULL) {
< 		printf("SimplePotential::countValueLines Could not open file '%s'\n", fileName);
< 		exit(-1);
< 	}
< 	char line[256];
< 	int count = 0;
< 
< 	while (fgets(line, 256, inp) != NULL) {
< 		// Ignore comments.
< 		int len = strlen(line);
< 		if (line[0] == '#') continue;
< 		if (len < 2) continue;
< 		count++;
< 	}
< 	fclose(inp);
< 	return count;
< }
<  
< SimplePotential::SimplePotential(const char* filename, SimplePotentialType type) : type(type) {
< 	FILE* inp = fopen(filename, "r");
< 	if (inp == NULL) {
< 		printf("SimplePotential::SimplePotential Could not open file '%s'\n", filename);
< 		exit(-1);
< 	}
< 	
< 	char line[256];
< 	
< 	size = (unsigned int) countValueLines(filename);
< 	float* r = new float[size];
< 	pot = new float[size];
< 	
< 	int count = 0;
< 	while (fgets(line, 256, inp) != NULL) {
< 		// Ignore comments.
< 		int len = strlen(line);
< 		if (line[0] == '#') continue;
< 		if (len < 2) continue;
< 		
< 		String s(line);
< 		int numTokens = s.tokenCount();
< 		if (numTokens != 2) {
< 			printf("SimplePotential::SimplePotential Invalid tabulated potential file line: %s\n", line);
< 			exit(-1);
< 		}
< 		
< 		String* tokenList = new String[numTokens];
< 		s.tokenize(tokenList);
< 		if (tokenList == NULL) {
< 			printf("SimplePotential::SimplePotential Invalid tabulated potential file line: %s\n", line);
< 			exit(-1);
< 		}
< 		r[count] = (float) strtod(tokenList[0], NULL);
< 		pot[count] = (float) strtod(tokenList[1], NULL);
< 		count++;
< 		
< 		delete[] tokenList;
< 	}
< 	fclose(inp);
< 
< 	if (type == BOND) {
< 	    step_inv = (size-1.0f) / (r[size-1]-r[0]);
< 	} else {
< 	    step_inv = 57.29578f * (size-1.0f) / (r[size-1]-r[0]);
< 	}
< 	delete[] r;
diff src/TabulatedPotential.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/TabulatedPotential.h
10,11c10,11
<     #define HOST
<     #define DEVICE
---
>     #define HOST 
>     #define DEVICE 
15,20d14
< #include "BaseGrid.h"
< 
< #ifdef __CUDA_ARCH__
< #include "CudaUtil.cuh"
< #endif
< 
29d22
< constexpr float BD_PI = 3.1415927f;
163c156
<   HOST DEVICE inline Vector3 computef(const Vector3 r, float d) const {
---
>   HOST DEVICE inline Vector3 computef(Vector3 r, float d) {
187,521d179
< 
< /* // New unified/simplified classes for working with potentials */
< /* <template int num_indices, int max_integer> */
< /* class BitMaskInts { */
< /*     BitMaskInts(); */
< 
< /* private: */
< /*     static_assert( ceil(log2(max_integer)) <= CHAR_BIT ); */
< 
< /*     char data[ ceil(num_indices * ceil(log2(max_integer)) / CHAR_BIT) ]; */
< 
< /*     HOST DEVICE inline unsigned short int get_int(i) const { */
< /* 	unsigned int first_bit = i * ceil(log2(max_integer)); */
< /* 	unsigned int last_bit  = (i+1) * ceil(log2(max_integer))-1; */
< /* 	char c0 = data[floor(first_bit/CHAR_BIT)]; */
< /* 	char c1 = data[floor(last_bit/CHAR_BIT)]; */
< 
< /* 	unsigned short int ret = c0 << (first_bit % CHAR_BIT) /\* shift left *\/ */
< /*     };     */
< 
< /* } */
< 
< 
< enum SimplePotentialType { UNSET, BOND, ANGLE, DIHEDRAL, VECANGLE };
< // enum PotentialTypeAtoms { bond=2, angle=3, dihedral=4 };
< 
< 
< class SimplePotential {
< public:
<     SimplePotential() { }
<     SimplePotential(const char* filename, SimplePotentialType type);
<     SimplePotential(float* pot, float step_inv, unsigned int size, SimplePotentialType type) :
< 	pot(pot), step_inv(step_inv), size(size), type(type) { }
<     
< 
<     float* pot;	     // actual potential values
<     float  step_inv; // angular increments of potential file
<     unsigned int size;     // number of data points in the file
< 
<     SimplePotentialType type;
< 
<     /* float start = 0;  */
<     /* bool is_periodic = false; */
< 
<     /* HOST void copy_to_device(SimplePotential* device_addr_p, unsigned int offset=0) { */
<     /* 	/\* Assumes device_addr_p is already allocated, allocates space for pot *\/ */
<     /* 	float* val, tmp; */
<     /* 	gpuErrchk(cudaMalloc(&val, sizeof(float)*size)); // TODO equivalent cudaFree */
<     /* 	gpuErrchk(cudaMemcpyAsync(val, pot, sizeof(float)*size, cudaMemcpyHostToDevice)); */
<     /* 	tmp = pot; */
<     /* 	pot = val; */
<     /* 	gpuErrchk(cudaMemcpyAsync(device_addr_p+offset, this, sizeof(SimplePotential), cudaMemcpyHostToDevice)); */
<     /* 	pot = tmp; */
<     /* 	// return val; */
<     /* } */
< 
<     HOST DEVICE inline float compute_value(const Vector3* __restrict__ pos,
< 					   const BaseGrid* __restrict__ sys,
< 					   const int* __restrict__ particles) const {
< 	float val;
< 	if (type == BOND)
< 	    val = compute_bond(pos, sys, particles[0], particles[1]);
< 	else if (type == ANGLE)
< 	    val = compute_angle(pos, sys, particles[0], particles[1], particles[2]);
< 	else if (type == DIHEDRAL)
< 	    val = compute_dihedral(pos, sys, particles[0], particles[1], particles[2], particles[3]);
< 	else if (type == VECANGLE)
< 	    val = compute_vecangle(pos, sys, particles[0], particles[1], particles[2], particles[3]);
< 	return val;
<     }
< 
<     HOST DEVICE inline float2 compute_energy_and_deriv(float value) {
< 	float2 ret;
< 	if (type == DIHEDRAL) {
< 	    ret = linearly_interpolate<true>(value, -BD_PI);
< 	} else {
< 	    ret = linearly_interpolate<false>(value);
< 	}
< 	return ret;
<     }
< 
<     HOST DEVICE inline float compute_bond(const Vector3* __restrict__ pos,
< 					      const BaseGrid* __restrict__ sys,
< 					      int i, int j) const {
< 	return sys->wrapDiff( pos[j] - pos[i] ).length();
<     }
< 
<     HOST DEVICE inline float compute_angle(const Vector3* __restrict__ pos,
< 					   const BaseGrid* __restrict__ sys,
< 					   int i, int j, int k) const {
< 	const Vector3 ab = sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = sys->wrapDiff(pos[k] - pos[j]);
< 	const Vector3 ac = sys->wrapDiff(pos[k] - pos[i]);
< 	return compute_angle( ab.length2(), bc.length2(), ac.length2() );
<     }
< 
<     HOST DEVICE inline float compute_vecangle(const Vector3* __restrict__ pos,
< 					      const BaseGrid* __restrict__ sys,
< 					      int i, int j, int k, int l) const {
< 	const Vector3 ab = sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = sys->wrapDiff(pos[l] - pos[k]);
< 	const Vector3 ac = bc+ab;
< 	return compute_angle( ab.length2(), bc.length2(), ac.length2() );
<     }
< 
<     HOST DEVICE inline float compute_angle(float distab2, float distbc2, float distac2) const {
< 	// Find the cosine of the angle we want - <ABC
< 	float cos = (distab2 + distbc2 - distac2);
< 
< 	distab2 = 1.0f/sqrt(distab2); //TODO: test other functions
< 	distbc2 = 1.0f/sqrt(distbc2);
< 	cos *= 0.5f * distbc2 * distab2;
< 
< 	// If the cosine is illegitimate, set it to 1 or -1 so that acos won't fail
< 	if (cos < -1.0f) cos = -1.0f;
< 	if (cos > 1.0f) cos = 1.0f;
< 
< 	return acos(cos);
<     }
< 
<     HOST DEVICE inline float compute_dihedral(const Vector3* __restrict__ pos,
< 					      const BaseGrid* __restrict__ sys,
< 					      int i, int j, int k, int l) const {
< 	const Vector3 ab = -sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = -sys->wrapDiff(pos[k] - pos[j]);
< 	const Vector3 cd = -sys->wrapDiff(pos[l] - pos[k]);
< 
< 	const Vector3 crossABC = ab.cross(bc);
< 	const Vector3 crossBCD = bc.cross(cd);
< 	const Vector3 crossX = bc.cross(crossABC);
< 
< 	const float cos_phi = crossABC.dot(crossBCD) / (crossABC.length() * crossBCD.length());
< 	const float sin_phi = crossX.dot(crossBCD) / (crossX.length() * crossBCD.length());
< 
< 	return -atan2(sin_phi,cos_phi);
<     }
< 
<     template <bool is_periodic>
< 	HOST DEVICE inline float2 linearly_interpolate(float x, float start=0.0f) const {
< 	float w = (x - start) * step_inv;
< 	int home = int( floorf(w) );
< 	w = w - home;
< 	// if (home < 0) return EnergyForce(v0[0], Vector3(0.0f));
< 	if (home < 0) {
< 	    if (is_periodic) home += size;
< 	    else return make_float2(pot[0],0.0f);
< 	}
< 	else if (home >= size) {
< 	    if (is_periodic) home -= size;
< 	    else return make_float2(pot[size-1],0.0f);
< 	}
< 
< 	float u0 = pot[home];
< 	float du = home+1 < size ? pot[home+1]-u0 : is_periodic ? pot[0]-u0 : 0;
< 
< 	return make_float2(du*w+u0, du*step_inv);
<     }
< 
<     DEVICE inline void apply_force(const Vector3* __restrict__ pos,
< 				   const BaseGrid* __restrict__ sys,
< 				   Vector3* __restrict__ forces,
< 				   int* particles, float energy_deriv) const {
< 	if (type == BOND)
< 	    apply_bond_force(pos, sys, forces, particles[0], particles[1], energy_deriv);
< 	else if (type == ANGLE)
< 	    apply_angle_force(pos, sys, forces, particles[0], particles[1],
< 			     particles[2], energy_deriv);
< 	else if (type == DIHEDRAL)
< 	    apply_dihedral_force(pos, sys, forces, particles[0], particles[1],
< 				 particles[2], particles[3], energy_deriv);
< 	else if (type == VECANGLE)
< 	    apply_vecangle_force(pos, sys, forces, particles[0], particles[1],
< 				 particles[2], particles[3], energy_deriv);
<     }
< 
<     __device__ inline void apply_bond_force(const Vector3* __restrict__ pos,
< 					const BaseGrid* __restrict__ sys,
< 					Vector3* __restrict__ force,
< 					int i, int j, float energy_deriv) const {
< #ifdef __CUDA_ARCH__
< 	Vector3 f = sys->wrapDiff( pos[j] - pos[i] );
< 	f = f * energy_deriv / f.length();
< 	atomicAdd(&force[i], f);
< 	atomicAdd(&force[j], -f);
< #endif
<     }
< 
<     struct TwoVector3 {
< 	Vector3 v1;
< 	Vector3 v2;
<     };
< 
<     DEVICE inline TwoVector3 get_angle_force(const Vector3& ab,
< 					     const Vector3& bc,
< 					     float energy_deriv) const {
< 	// Find the distance between each pair of particles
< 	float distab = ab.length2();
< 	float distbc = bc.length2();
< 	const float distac2 = (ab+bc).length2();
< 
< 	// Find the cosine of the angle we want - <ABC
< 	float cos = (distab + distbc - distac2);
< 
< 	distab = 1.0f/sqrt(distab); //TODO: test other functions
< 	distbc = 1.0f/sqrt(distbc);
< 	cos *= 0.5f * distbc * distab;
< 
< 	// If the cosine is illegitimate, set it to 1 or -1 so that acos won't fail
< 	if (cos < -1.0f) cos = -1.0f;
< 	if (cos > 1.0f) cos = 1.0f;
< 
< 	float sin = sqrtf(1.0f - cos*cos);
< 	energy_deriv /= abs(sin) > 1e-3 ? sin : 1e-3; // avoid singularity
< 	if (abs(sin) < 1e-3) {
< 	    printf("BAD ANGLE: sin, cos, energy_deriv, distab, distbc, distac2: (%f %f %f %f %f)\n",
< 		   sin,cos,energy_deriv,distab,distbc);	}
< 
< 	// Calculate the forces
< 	TwoVector3 force;
< 	force.v1 = (energy_deriv*distab) * (ab * (cos*distab) + bc * distbc); // force on 1st particle
< 	force.v2 = -(energy_deriv*distbc) * (bc * (cos*distbc) + ab * distab); // force on last particle
< 	return force;
<     }
< 
<     // DEVICE inline TwoVector3 get_angle_force(const Vector3& ab,
<     // 					     const Vector3& bc,
<     // 					     float energy_deriv) const {
<     // 	// Find the distance between each pair of particles
<     // 	float distab = ab.length2();
<     // 	float distbc = bc.length2();
< 
<     // 	float pre = distab*distbc - pow(ab.dot(bc),2);
<     // 	// if (pre < 1e-6) {
<     // 	//     pre = 1e-3;
<     // 	//     printf("BAD ANGLE: pre, energy_deriv, distab, distbc, ab.dot(bc): (%f %f %f %f %f)\n",
<     // 	// 	   pre,energy_deriv,distab,distbc,ab.dot(bc));	
<     // 	// } else pre = sqrt(pre);
<     // 	// if (distab == distbc) {
<     // 	//     printf("GOOD ANGLE: pre, energy_deriv, distab, distbc, ab.dot(bc): (%f %f %f %f %f)\n",
<     // 	// 	   pre,energy_deriv,distab,distbc,ab.dot(bc));	
<     // 	// }
< 	    
<     // 	pre = pre > 1e-6 ? sqrt(pre) : 1e-3;
<     // 	energy_deriv /= pre;
< 
<     // 	TwoVector3 force;
<     // 	//force.v1 = energy_deriv * Vector3::element_mult( 1-Vector3::element_mult(ab,ab)/distab, bc);
<     // 	//force.v2 = energy_deriv * Vector3::element_mult( 1-Vector3::element_mult(bc,bc)/distbc, ab);
< 
<     // 	Vector3 abbc = Vector3::element_mult(-ab,bc);
<     // 	force.v1 = -energy_deriv * (bc-Vector3::element_mult(abbc, -ab/distab));
<     // 	force.v2 = -energy_deriv * (-ab-Vector3::element_mult(abbc, bc/distbc));
<     // 	return force;
<     // }
< 
<     DEVICE inline void apply_angle_force(const Vector3* __restrict__ pos,
< 					 const BaseGrid* __restrict__ sys,
< 					 Vector3* __restrict__ force,
< 					 int i, int j, int k, float energy_deriv) const {
< 
< #ifdef __CUDA_ARCH__
< 	const Vector3 ab = sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = sys->wrapDiff(pos[k] - pos[j]);
< 	// const Vector3 ac = sys->wrapDiff(pos[k] - pos[i]);
< 
< 	TwoVector3 f = get_angle_force(ab,bc, energy_deriv);
< 
< 	atomicAdd( &force[i], f.v1 );
< 	atomicAdd( &force[j], -(f.v1 + f.v2) );
< 	atomicAdd( &force[k], f.v2 );
< #endif
<     }
< 
<     DEVICE inline void apply_dihedral_force(const Vector3* __restrict__ pos,
< 					    const BaseGrid* __restrict__ sys,
< 					    Vector3* __restrict__ force,
< 					    int i, int j, int k, int l, float energy_deriv) const {
< #ifdef __CUDA_ARCH__
< 	const Vector3 ab = -sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = -sys->wrapDiff(pos[k] - pos[j]);
< 	const Vector3 cd = -sys->wrapDiff(pos[l] - pos[k]);
< 
< 	const Vector3 crossABC = ab.cross(bc);
< 	const Vector3 crossBCD = bc.cross(cd);
< 	const Vector3 crossX = bc.cross(crossABC);
< 
< 	const float cos_phi = crossABC.dot(crossBCD) / (crossABC.length() * crossBCD.length());
< 	const float sin_phi = crossX.dot(crossBCD) / (crossX.length() * crossBCD.length());
< 
< 	// return -atan2(sin_phi,cos_phi);
< 	Vector3 f1, f2, f3; // forces
< 	float distbc = bc.length();
< 
< 	f1 = -distbc * crossABC.rLength2() * crossABC;
< 	f3 = -distbc * crossBCD.rLength2() * crossBCD;
< 	f2 = -(ab.dot(bc) * bc.rLength2()) * f1 - (bc.dot(cd) * bc.rLength2()) * f3;
< 
< 	// energy_deriv = (ab.length2()*bc.length2()*crossABC.rLength2() > 100.0f || bc.length2()*cd.length2()*crossBCD.rLength2() > 100.0f) ? 0.0f : energy_deriv;
< 	/* if ( energy_deriv > 1000.0f ) */
< 	/*     energy_deriv = 1000.0f; */
< 	/* if ( energy_deriv < -1000.0f ) */
< 	/*     energy_deriv = -1000.0f; */
< 
< 	f1 *= energy_deriv;
< 	f2 *= energy_deriv;
< 	f3 *= energy_deriv;
< 
< 	atomicAdd( &force[i], f1 );
< 	atomicAdd( &force[j], f2-f1 );
< 	atomicAdd( &force[k], f3-f2 );
< 	atomicAdd( &force[l], -f3 );
< #endif
<     }
<     DEVICE inline void apply_vecangle_force(const Vector3* __restrict__ pos,
< 					    const BaseGrid* __restrict__ sys,
< 					    Vector3* __restrict__ force,
< 					    int i, int j, int k, int l, float energy_deriv) const {
< 
< #ifdef __CUDA_ARCH__
< 
< 	const Vector3 ab = -sys->wrapDiff(pos[j] - pos[i]);
< 	const Vector3 bc = -sys->wrapDiff(pos[k] - pos[j]);
< 	// const Vector3 ac = sys->wrapDiff(pos[k] - pos[i]);
< 
< 	TwoVector3 f = get_angle_force(ab,bc, energy_deriv);
< 
< 	atomicAdd( &force[i], f.v1 );
< 	atomicAdd( &force[j], -f.v1 );
< 	atomicAdd( &force[k], -f.v2 );
< 	atomicAdd( &force[l], f.v2 );
< #endif
<     }
< 
< };
< 
526d183
< 
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: TabulatedPotential.o
diff src/TrajectoryWriter.h /data/server2/pinyili2/arbd_software/arbd.after_server5/src/TrajectoryWriter.h
55,58c55,58
< 
<     double bc = box.ey().dot(box.ez());
<     double ac = box.ex().dot(box.ez());
<     double ab = box.ex().dot(box.ey());
---
>     
>     float bc = box.ey().dot(box.ez());
>     float ac = box.ex().dot(box.ez());
>     float ab = box.ex().dot(box.ey());
62,66c62
<     unitCell[4] = ab/unitCell[2]/unitCell[5]/pi*180.0f;
< 
<     unitCell[1] = unitCell[1] > 1.0 ? 1.0 : unitCell[1] < -1.0 ? -1.0 : unitCell[1];
<     unitCell[3] = unitCell[3] > 1.0 ? 1.0 : unitCell[3] < -1.0 ? -1.0 : unitCell[3];
<     unitCell[4] = unitCell[4] > 1.0 ? 1.0 : unitCell[4] < -1.0 ? -1.0 : unitCell[4];
---
>     unitCell[4] = ab/unitCell[0]/unitCell[1]/pi*180.0f;
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: useful.o
Only in /data/server2/pinyili2/arbd_software/arbd.after_server5/src: WKFUtils.o
